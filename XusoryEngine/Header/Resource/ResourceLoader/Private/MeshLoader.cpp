#include "../MeshLoader.h"

namespace XusoryEngine
{
	std::shared_ptr<Mesh> ObjMeshLoader::LoadMesh(const std::wstring_view& path)
	{
		const auto meshFile = File(path, FileOpenMode::READ);
		const auto meshData = meshFile.ReadText();
		const auto meshDataList = StringEx::SplitView<std::string>(meshData, "\r\n");

		std::unique_ptr<IObjParser> objParser;
		if (StringEx::BeginWith<std::string>(meshDataList.at(0), "# Blender"))
		{
			objParser = std::unique_ptr<IObjParser>(ObjParserFactory::GetFactory("Blender"));
		}
		else if (StringEx::BeginWith<std::string>(meshDataList.at(0), "# WaveFront *.obj file (generated by Cinema 4D)"))
		{
			objParser = std::unique_ptr<IObjParser>(ObjParserFactory::GetFactory("Cinema4D"));
		}
		else if (StringEx::BeginWith<std::string>(meshDataList.at(0), "# 3ds Max Wavefront OBJ Exporter"))
		{
			objParser = std::unique_ptr<IObjParser>(ObjParserFactory::GetFactory("3dsMax"));
		}

		UINT startIndex = 0;
		std::vector<Float3> positionList;
		std::vector<Float3> normalList;
		std::vector<Float2> uvList;

		const auto mesh = objParser->ParseObjMesh(meshDataList, startIndex, positionList, normalList, uvList);
		return mesh;
	}

	std::vector<std::shared_ptr<Mesh>> ObjMeshLoader::LoadSeveralMesh(const std::wstring_view& path)
	{
		const auto meshFile = File(path, FileOpenMode::READ);
		const auto meshData = meshFile.ReadText();
		const auto meshDataList = StringEx::SplitView<std::string>(meshData, "\r\n");

		std::unique_ptr<IObjParser> objParser;
		if (StringEx::BeginWith<std::string>(meshDataList.at(0), "# Blender"))
		{
			objParser = std::unique_ptr<IObjParser>(ObjParserFactory::GetFactory("Blender"));
		}
		else if (StringEx::BeginWith<std::string>(meshDataList.at(0), "# WaveFront *.obj file (generated by Cinema 4D)"))
		{
			objParser = std::unique_ptr<IObjParser>(ObjParserFactory::GetFactory("Cinema4D"));
		}
		else if (StringEx::BeginWith<std::string>(meshDataList.at(0), "# 3ds Max Wavefront OBJ Exporter"))
		{
			objParser = std::unique_ptr<IObjParser>(ObjParserFactory::GetFactory("3dsMax"));
		}

		UINT dataIndex = 0;
		std::vector<Float3> positionList;
		std::vector<Float3> normalList;
		std::vector<Float2> uvList;

		std::vector<std::shared_ptr<Mesh>> meshList;
		while (true)
		{
			if (dataIndex == meshDataList.size() - 2)
			{
				break;
			}

			meshList.emplace_back(objParser->ParseObjMesh(meshDataList, dataIndex, positionList, normalList, uvList));
		}

		return meshList;
	}

	std::shared_ptr<Mesh> BlenderObjLoader::ParseObjMesh(const std::vector<std::string_view>& meshDataList, UINT& dataIndex,
		std::vector<Float3>& positionList, std::vector<Float3>& normalList, std::vector<Float2>& uvList)
	{
		return std::shared_ptr<Mesh>();
	}

	std::shared_ptr<Mesh> C4dObjLoader::ParseObjMesh(const std::vector<std::string_view>& meshDataList, UINT& dataIndex,
		std::vector<Float3>& positionList, std::vector<Float3>& normalList, std::vector<Float2>& uvList)
	{
		return std::shared_ptr<Mesh>();
	}

	std::shared_ptr<Mesh> MaxObjLoader::ParseObjMesh(const std::vector<std::string_view>& meshDataList, UINT& dataIndex,
		std::vector<Float3>& positionList, std::vector<Float3>& normalList, std::vector<Float2>& uvList)
	{
		std::string meshName;

		for (; dataIndex < static_cast<UINT>(meshDataList.size()); dataIndex++)
		{
			if (auto& dataStr = meshDataList.at(dataIndex); StringEx::BeginWith<std::string>(dataStr, "# object"))
			{
				meshName = StringEx::Split<std::string>(dataStr, " ").at(2);

				dataIndex += 3;
				break;
			}
		}

		UINT positionNum = 0;
		UINT normalNum = 0;
		UINT uvNum = 0;

		UINT indexTemp = dataIndex;
		for (; indexTemp < static_cast<UINT>(meshDataList.size()); indexTemp++)
		{
			if (StringEx::EndWith<std::string>(meshDataList.at(indexTemp), "vertices"))
			{
				auto positionNumStr = StringEx::Split<std::string>(meshDataList.at(indexTemp), " ").at(1);
				positionNum = std::stoi(positionNumStr);
				break;
			}
		}
		for (; indexTemp < static_cast<UINT>(meshDataList.size()); indexTemp++)
		{
			if (auto& dataStr = meshDataList.at(indexTemp);
				StringEx::EndWith<std::string>(dataStr, "vertex normals"))
			{
				auto normalNumStr = StringEx::Split<std::string>(meshDataList.at(indexTemp), " ").at(1);
				normalNum = std::stoi(normalNumStr);
				break;
			}
		}
		for (; indexTemp < static_cast<UINT>(meshDataList.size()); indexTemp++)
		{
			if (auto& dataStr = meshDataList.at(indexTemp);
				StringEx::EndWith<std::string>(dataStr, "texture coords"))
			{
				auto uvNumStr = StringEx::Split<std::string>(meshDataList.at(indexTemp), " ").at(1);
				uvNum = std::stoi(uvNumStr);
				break;
			}
		}

		UINT positionListSizeTemp = static_cast<UINT>(positionList.size());
		UINT normalListSizeTemp = static_cast<UINT>(normalList.size());
		UINT uvListSizeTemp = static_cast<UINT>(uvList.size());
		positionList.resize(positionListSizeTemp + positionNum);
		normalList.resize(normalListSizeTemp + normalNum);
		uvList.resize(uvListSizeTemp + uvNum);
		
		for (UINT i = positionListSizeTemp, j = 0; j < positionNum; i++, j++, dataIndex++)
		{
			auto positionStrList = StringEx::Split<std::string>(meshDataList.at(dataIndex), " ");
			positionList.at(i) = Float3(std::stof(positionStrList.at(2)), std::stof(positionStrList.at(3)), std::stof(positionStrList.at(4)));
		}
		dataIndex += 2;

		for (UINT i = normalListSizeTemp, j = 0; j < normalNum; i++, j++, dataIndex++)
		{
			auto normalStrList = StringEx::Split<std::string>(meshDataList.at(dataIndex), " ");
			normalList.at(i) = Float3(std::stof(normalStrList.at(1)), std::stof(normalStrList.at(2)), std::stof(normalStrList.at(3)));
		}
		if (normalNum != 0) dataIndex += 2;

		for (UINT i = uvListSizeTemp, j = 0; j < uvNum; i++, j++, dataIndex++)
		{
			auto uvStrList = StringEx::Split<std::string>(meshDataList.at(dataIndex), " ");
			uvList.at(i) = Float2(std::stof(uvStrList.at(1)), 1.0f - std::stof(uvStrList.at(2)));
		}
		if (uvNum != 0) dataIndex += 2;
		dataIndex += 2;

		auto mesh = std::make_shared<Mesh>(meshName);

		indexTemp = 0;
		for (; ; dataIndex++)
		{
			if (StringEx::EndWith<std::string>(meshDataList.at(dataIndex), "faces") ||
				StringEx::EndWith<std::string>(meshDataList.at(dataIndex), "polygons") ||
				StringEx::EndWith<std::string>(meshDataList.at(dataIndex), "triangles"))
			{
				dataIndex++;
				break;
			}

			auto faceStrList = StringEx::SplitView<std::string>(meshDataList.at(dataIndex), " ");
			faceStrList.pop_back();

			for (UINT i = 1; i < static_cast<UINT>(faceStrList.size()); i++)
			{
				auto indexStrList = StringEx::Split<std::string>(faceStrList.at(i), "/");

				Vertex vertex;
				vertex.position = positionList.at(std::stoi(indexStrList.at(0)) - 1);

				if (uvList.size() != 0)
				{
					vertex.uv0 = uvList.at(std::stoi(indexStrList.at(1)) - 1);
					if (normalList.size() != 0)
					{
						vertex.normal = normalList.at(std::stoi(indexStrList.at(2)) - 1);
					}
				}
				else
				{
					if (normalList.size() != 0)
					{
						vertex.normal = normalList.at(std::stoi(indexStrList.at(1)) - 1);
					}
				}

				mesh->AddVertex(vertex);
			}

			UINT faceNum = static_cast<UINT>(faceStrList.size()) - 1;
			if (faceNum == 3)
			{
				mesh->AddTriangleIndex(indexTemp, indexTemp + 1, indexTemp + 2);
			}
			else if (faceNum == 4)
			{
				mesh->AddTriangleIndex(indexTemp, indexTemp + 1, indexTemp + 2);
				mesh->AddTriangleIndex(indexTemp, indexTemp + 2, indexTemp + 3);
			}
			indexTemp += faceNum;
		}

		return mesh;
	}
}
